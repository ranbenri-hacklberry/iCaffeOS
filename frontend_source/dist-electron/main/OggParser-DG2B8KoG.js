import { b as g, j as C, f as l, S as p, m as F, p as i, J as _, c as d, y as b, a as T, k as u, h as I, F as N, B as E, E as z, d as H } from "./index-bK5HZUl9.js";
import "node:fs/promises";
import { V as w, F as x, B as k, a as h, b as L, c as B } from "./FlacParser-lRrTlqWg.js";
import "electron";
import "path";
import "fs";
import "os";
import "child_process";
import "net";
import "url";
import "crypto";
import "fs/promises";
import "zlib";
import "stream/promises";
import "stream";
import "tty";
import "util";
import "./AbstractID3Parser-CTeHmgKc.js";
import "./ID3v2Parser-B-b0-MnZ.js";
class v extends F("Opus") {
}
class A {
  constructor(e) {
    if (e < 19)
      throw new v("ID-header-page 0 should be at least 19 bytes long");
    this.len = e;
  }
  get(e, t) {
    return {
      magicSignature: new p(8, "ascii").get(e, t + 0),
      version: g.get(e, t + 8),
      channelCount: g.get(e, t + 9),
      preSkip: C.get(e, t + 10),
      inputSampleRate: l.get(e, t + 12),
      outputGain: C.get(e, t + 16),
      channelMapping: g.get(e, t + 18)
    };
  }
}
class U extends w {
  constructor(e, t, s) {
    super(e, t), this.idHeader = null, this.lastPos = -1, this.tokenizer = s, this.durationOnLastPage = !0;
  }
  /**
   * Parse first Opus Ogg page
   * @param {IPageHeader} header
   * @param {Uint8Array} pageData
   */
  parseFirstPage(e, t) {
    if (this.metadata.setFormat("codec", "Opus"), this.idHeader = new A(t.length).get(t, 0), this.idHeader.magicSignature !== "OpusHead")
      throw new v("Illegal ogg/Opus magic-signature");
    this.metadata.setFormat("sampleRate", this.idHeader.inputSampleRate), this.metadata.setFormat("numberOfChannels", this.idHeader.channelCount), this.metadata.setAudioOnly();
  }
  async parseFullPage(e) {
    switch (new p(8, "ascii").get(e, 0)) {
      case "OpusTags":
        await this.parseUserCommentList(e, 8), this.lastPos = this.tokenizer.position - e.length;
        break;
    }
  }
  calculateDuration(e) {
    if (this.lastPageHeader && (e || this.lastPageHeader.headerType.lastPage) && this.metadata.format.sampleRate && this.lastPageHeader.absoluteGranulePosition >= 0) {
      const t = this.lastPageHeader.absoluteGranulePosition - this.idHeader.preSkip;
      if (this.metadata.setFormat("numberOfSamples", t), this.metadata.setFormat("duration", t / 48e3), this.lastPos !== -1 && this.tokenizer.fileInfo.size && this.metadata.format.duration) {
        const s = this.tokenizer.fileInfo.size - this.lastPos;
        this.metadata.setFormat("bitrate", 8 * s / this.metadata.format.duration);
      }
    }
  }
}
const $ = {
  len: 80,
  get: (a, e) => ({
    speex: new p(8, "ascii").get(a, e + 0),
    version: _(new p(20, "ascii").get(a, e + 8)),
    version_id: i.get(a, e + 28),
    header_size: i.get(a, e + 32),
    rate: i.get(a, e + 36),
    mode: i.get(a, e + 40),
    mode_bitstream_version: i.get(a, e + 44),
    nb_channels: i.get(a, e + 48),
    bitrate: i.get(a, e + 52),
    frame_size: i.get(a, e + 56),
    vbr: i.get(a, e + 60),
    frames_per_packet: i.get(a, e + 64),
    extra_headers: i.get(a, e + 68),
    reserved1: i.get(a, e + 72),
    reserved2: i.get(a, e + 76)
  })
}, R = d("music-metadata:parser:ogg:speex");
class V extends w {
  constructor(e, t, s) {
    super(e, t);
  }
  /**
   * Parse first Speex Ogg page
   * @param {IPageHeader} header
   * @param {Uint8Array} pageData
   */
  parseFirstPage(e, t) {
    R("First Ogg/Speex page");
    const s = $.get(t, 0);
    this.metadata.setFormat("codec", `Speex ${s.version}`), this.metadata.setFormat("numberOfChannels", s.nb_channels), this.metadata.setFormat("sampleRate", s.rate), s.bitrate !== -1 && this.metadata.setFormat("bitrate", s.bitrate), this.metadata.setAudioOnly();
  }
}
const M = {
  len: 42,
  get: (a, e) => ({
    id: new p(7, "ascii").get(a, e),
    vmaj: g.get(a, e + 7),
    vmin: g.get(a, e + 8),
    vrev: g.get(a, e + 9),
    vmbw: T.get(a, e + 10),
    vmbh: T.get(a, e + 17),
    nombr: b.get(a, e + 37),
    nqual: g.get(a, e + 40)
  })
}, y = d("music-metadata:parser:ogg:theora");
class D {
  constructor(e, t, s) {
    this.durationOnLastPage = !1, this.metadata = e;
  }
  /**
   * Vorbis 1 parser
   * @param header Ogg Page Header
   * @param pageData Page data
   */
  async parsePage(e, t) {
    e.headerType.firstPage && await this.parseFirstPage(e, t);
  }
  calculateDuration() {
    y("duration calculation not implemented");
  }
  /**
   * Parse first Theora Ogg page. the initial identification header packet
   */
  async parseFirstPage(e, t) {
    y("First Ogg/Theora page"), this.metadata.setFormat("codec", "Theora");
    const s = M.get(t, 0);
    this.metadata.setFormat("bitrate", s.nombr), this.metadata.setFormat("hasVideo", !0);
  }
  flush() {
    return Promise.resolve();
  }
}
const G = {
  len: 27,
  get: (a, e) => ({
    capturePattern: new p(4, "latin1").get(a, e),
    version: g.get(a, e + 4),
    headerType: {
      continued: u(a, e + 5, 0),
      firstPage: u(a, e + 5, 1),
      lastPage: u(a, e + 5, 2)
    },
    // packet_flag: Token.UINT8.get(buf, off + 5),
    absoluteGranulePosition: Number(I.get(a, e + 6)),
    streamSerialNumber: l.get(a, e + 14),
    pageSequenceNo: l.get(a, e + 18),
    pageChecksum: l.get(a, e + 22),
    page_segments: g.get(a, e + 26)
  })
};
class O {
  static sum(e, t, s) {
    const o = new DataView(e.buffer, 0);
    let r = 0;
    for (let m = t; m < t + s; ++m)
      r += o.getUint8(m);
    return r;
  }
  constructor(e) {
    this.len = e.page_segments;
  }
  get(e, t) {
    return {
      totalPageSize: O.sum(e, t, this.len)
    };
  }
}
const P = d("music-metadata:parser:ogg:theora");
class q {
  constructor(e, t, s) {
    this.durationOnLastPage = !1, this.metadata = e, this.options = t, this.tokenizer = s, this.flacParser = new x(this.metadata, this.tokenizer, t);
  }
  /**
   * Vorbis 1 parser
   * @param header Ogg Page Header
   * @param pageData Page data
   */
  async parsePage(e, t) {
    e.headerType.firstPage && await this.parseFirstPage(e, t);
  }
  calculateDuration() {
    P("duration calculation not implemented");
  }
  /**
   * Parse first Theora Ogg page. the initial identification header packet
   */
  async parseFirstPage(e, t) {
    if (P("First Ogg/FLAC page"), (await N.get(t, 9)).toString() !== "fLaC")
      throw new Error("Invalid FLAC preamble");
    const o = await k.get(t, 13);
    await this.parseDataBlock(o, t.subarray(13 + k.len));
  }
  async parseDataBlock(e, t) {
    switch (P(`blockHeader type=${e.type}, length=${e.length}`), e.type) {
      case h.STREAMINFO: {
        const s = B.get(t, 0);
        return this.flacParser.processsStreamInfo(s);
      }
      case h.PADDING:
        break;
      case h.APPLICATION:
        break;
      case h.SEEKTABLE:
        break;
      case h.VORBIS_COMMENT:
        return this.flacParser.parseComment(t);
      case h.PICTURE:
        if (!this.options.skipCovers) {
          const s = new L(t.length).get(t, 0);
          return this.flacParser.addPictureTag(s);
        }
        break;
      default:
        this.metadata.addWarning(`Unknown block type: ${e.type}`);
    }
    return this.tokenizer.ignore(e.length).then();
  }
  flush() {
    return Promise.resolve();
  }
}
class S extends F("Ogg") {
}
const n = d("music-metadata:parser:ogg");
class j {
  constructor(e, t, s) {
    this.pageNumber = 0, this.closed = !1, this.metadata = e, this.streamSerial = t, this.options = s;
  }
  async parsePage(e, t) {
    this.pageNumber = t.pageSequenceNo, n("serial=%s page#=%s, Ogg.id=%s", t.streamSerialNumber, t.pageSequenceNo, t.capturePattern);
    const s = await e.readToken(new O(t));
    n("totalPageSize=%s", s.totalPageSize);
    const o = await e.readToken(new H(s.totalPageSize));
    if (n("firstPage=%s, lastPage=%s, continued=%s", t.headerType.firstPage, t.headerType.lastPage, t.headerType.continued), t.headerType.firstPage) {
      this.metadata.setFormat("container", "Ogg");
      const r = o.subarray(0, 7), m = Array.from(r).filter((c) => c >= 32 && c <= 126).map((c) => String.fromCharCode(c)).join("");
      switch (m) {
        case "vorbis":
          n(`Set Ogg stream serial ${t.streamSerialNumber}, codec=Vorbis`), this.pageConsumer = new w(this.metadata, this.options);
          break;
        case "OpusHea":
          n("Set page consumer to Ogg/Opus"), this.pageConsumer = new U(this.metadata, this.options, e);
          break;
        case "Speex  ":
          n("Set page consumer to Ogg/Speex"), this.pageConsumer = new V(this.metadata, this.options, e);
          break;
        case "fishead":
        case "theora":
          n("Set page consumer to Ogg/Theora"), this.pageConsumer = new D(this.metadata, this.options, e);
          break;
        case "FLAC":
          n("Set page consumer to Vorbis"), this.pageConsumer = new q(this.metadata, this.options, e);
          break;
        default:
          throw new S(`Ogg codec not recognized (id=${m}`);
      }
    }
    if (t.headerType.lastPage && (this.closed = !0), this.pageConsumer)
      await this.pageConsumer.parsePage(t, o);
    else
      throw new Error("pageConsumer should be initialized");
  }
}
class he extends E {
  constructor() {
    super(...arguments), this.streams = /* @__PURE__ */ new Map();
  }
  /**
   * Parse page
   * @returns {Promise<void>}
   */
  async parse() {
    var s, o;
    this.streams = /* @__PURE__ */ new Map();
    let e = !1, t;
    try {
      do {
        if (t = await this.tokenizer.readToken(G), t.capturePattern !== "OggS")
          throw new S("Invalid Ogg capture pattern");
        let r = this.streams.get(t.streamSerialNumber);
        if (r || (r = new j(this.metadata, t.streamSerialNumber, this.options), this.streams.set(t.streamSerialNumber, r)), await r.parsePage(this.tokenizer, t), r.pageNumber > 12 && !(this.options.duration && [...this.streams.values()].find((m) => {
          var c;
          return (c = m.pageConsumer) == null ? void 0 : c.durationOnLastPage;
        }))) {
          n("Stop processing Ogg stream");
          break;
        }
      } while (![...this.streams.values()].every((r) => r.closed));
    } catch (r) {
      if (r instanceof z)
        n("Reached end-of-stream"), e = !0;
      else if (r instanceof S)
        this.metadata.addWarning(`Corrupt Ogg content at ${this.tokenizer.position}`);
      else
        throw r;
    }
    for (const r of this.streams.values())
      r.closed || (this.metadata.addWarning(`End-of-stream reached before reaching last page in Ogg stream serial=${r.streamSerial}`), await ((s = r.pageConsumer) == null ? void 0 : s.flush())), (o = r.pageConsumer) == null || o.calculateDuration(e);
  }
}
export {
  S as OggContentError,
  he as OggParser
};
