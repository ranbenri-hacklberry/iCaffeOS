import { U as w, N as G, D as V, y as Y, k as b, O as N, c as K, P as I, e as T, b as U, Q as j, R as z, V as X, A as Z, m as Q, G as q, K as J, W as P, d as y } from "./index-CfVcE9IC.js";
const F = {
  len: 16,
  get: (n, e) => {
    const t = w.get(n, e + 8), a = w.get(n, e + 12);
    return {
      startTime: w.get(n, e),
      endTime: w.get(n, e + 4),
      startOffset: t === 4294967295 ? void 0 : t,
      endOffset: a === 4294967295 ? void 0 : a
    };
  }
};
function W(n) {
  switch (n) {
    case 2:
      return 6;
    case 3:
    case 4:
      return 10;
    default:
      throw B(n);
  }
}
function _(n) {
  return {
    status: {
      tag_alter_preservation: b(n, 0, 6),
      file_alter_preservation: b(n, 0, 5),
      read_only: b(n, 0, 4)
    },
    format: {
      grouping_identity: b(n, 1, 7),
      compression: b(n, 1, 3),
      encryption: b(n, 1, 2),
      unsynchronisation: b(n, 1, 1),
      data_length_indicator: b(n, 1, 0)
    }
  };
}
function L(n, e, t) {
  switch (e) {
    case 2:
      return A(n, e, t);
    case 3:
    case 4:
      return ee(n, e, t);
    default:
      throw B(e);
  }
}
function A(n, e, t) {
  const a = {
    id: V(n.subarray(0, 3), "ascii"),
    length: Y.get(n, 3)
  };
  return a.id.match(/^[A-Z0-9]{3}$/) || t.addWarning(`Invalid ID3v2.${e} frame-header-ID: ${a.id}`), a;
}
function ee(n, e, t) {
  const a = {
    id: V(n.subarray(0, 4), "ascii"),
    length: (e === 4 ? G : w).get(n, 4),
    flags: _(n.subarray(8, 10))
  };
  return a.id.match(/^[A-Z0-9]{4}$/) || t.addWarning(`Invalid ID3v2.${e} frame-header-ID: ${a.id}`), a;
}
function B(n) {
  throw new E(`Unexpected majorVer: ${n}`);
}
const $ = K("music-metadata:id3v2:frame-parser"), u = "latin1", M = { encoding: u, bom: !1 };
function te(n) {
  const e = [];
  let t, a = "";
  for (const i of n)
    if (typeof t == "string")
      if (i === "(" && t === "")
        a += "(", t = void 0;
      else if (i === ")") {
        a !== "" && (e.push(a), a = "");
        const o = R(t);
        o && e.push(o), t = void 0;
      } else
        t += i;
    else
      i === "(" ? t = "" : a += i;
  return a && (e.length === 0 && a.match(/^\d*$/) && (a = R(a)), a && e.push(a)), e;
}
function R(n) {
  if (n === "RX")
    return "Remix";
  if (n === "CR")
    return "Cover";
  if (n.match(/^\d*$/))
    return q[Number.parseInt(n, 10)];
}
class l {
  /**
   * Create id3v2 frame parser
   * @param major - Major version, e.g. (4) for  id3v2.4
   * @param warningCollector - Used to collect decode issue
   */
  constructor(e, t) {
    this.major = e, this.warningCollector = t;
  }
  readData(e, t, a) {
    if (e.length === 0) {
      this.warningCollector.addWarning(`id3v2.${this.major} header has empty tag type=${t}`);
      return;
    }
    const { encoding: i, bom: o } = N.get(e, 0), g = e.length;
    let d = 0, c = [];
    const m = l.getNullTerminatorLength(i);
    let h;
    switch ($(`Parsing tag type=${t}, encoding=${i}, bom=${o}`), t !== "TXXX" && t[0] === "T" ? "T*" : t) {
      case "T*":
      case "GRP1":
      case "GP1":
      case "IPLS":
      case "MVIN":
      case "MVNM":
      case "PCS":
      case "PCST": {
        let s;
        try {
          s = l.trimNullPadding(T(e.subarray(1), i));
        } catch (r) {
          if (r instanceof Error) {
            this.warningCollector.addWarning(`id3v2.${this.major} type=${t} header has invalid string value: ${r.message}`);
            break;
          }
          throw r;
        }
        switch (t) {
          case "TMCL":
          case "TIPL":
          case "IPLS":
            c = l.functionList(this.splitValue(t, s));
            break;
          case "TRK":
          case "TRCK":
          case "TPOS":
          case "TIT1":
          case "TIT2":
          case "TIT3":
            c = s;
            break;
          case "TCOM":
          case "TEXT":
          case "TOLY":
          case "TOPE":
          case "TPE1":
          case "TSRC":
            c = this.splitValue(t, s);
            break;
          case "TCO":
          case "TCON":
            c = this.splitValue(t, s).map((r) => te(r)).reduce((r, f) => r.concat(f), []);
            break;
          case "PCS":
          case "PCST":
            c = this.major >= 4 ? this.splitValue(t, s) : [s], c = Array.isArray(c) && c[0] === "" ? 1 : 0;
            break;
          default:
            c = this.major >= 4 ? this.splitValue(t, s) : [s];
        }
        break;
      }
      case "TXXX": {
        const s = l.readIdentifierAndData(e.subarray(1), i);
        c = {
          description: s.id,
          text: this.splitValue(t, T(s.data, i).replace(/\x00+$/, ""))
        };
        break;
      }
      case "PIC":
      case "APIC":
        if (a) {
          const s = {};
          switch (e = e.subarray(1), this.major) {
            case 2:
              s.format = T(e.subarray(0, 3), "latin1"), e = e.subarray(3);
              break;
            case 3:
            case 4:
              h = I(e, u), s.format = T(e.subarray(0, h), u), e = e.subarray(h + 1);
              break;
            default:
              throw ae(this.major);
          }
          s.format = l.fixPictureMimeType(s.format), s.type = Z[e[0]], e = e.subarray(1), h = I(e, i), s.description = T(e.subarray(0, h), i), e = e.subarray(h + m), s.data = e, c = s;
        }
        break;
      case "CNT":
      case "PCNT":
        c = j(e);
        break;
      case "SYLT": {
        const s = X.get(e, 0);
        e = e.subarray(X.len);
        const r = {
          descriptor: "",
          language: s.language,
          contentType: s.contentType,
          timeStampFormat: s.timeStampFormat,
          syncText: []
        };
        let f = !1;
        for (; e.length > 0; ) {
          const p = l.readNullTerminatedString(e, s.encoding);
          if (e = e.subarray(p.len), f) {
            const k = w.get(e, 0);
            e = e.subarray(w.len), r.syncText.push({
              text: p.text,
              timestamp: k
            });
          } else
            r.descriptor = p.text, f = !0;
        }
        c = r;
        break;
      }
      case "ULT":
      case "USLT":
      case "COM":
      case "COMM": {
        const s = z.get(e, d);
        d += z.len;
        const r = l.readNullTerminatedString(e.subarray(d), s.encoding);
        d += r.len;
        const f = l.readNullTerminatedString(e.subarray(d), s.encoding);
        c = {
          language: s.language,
          descriptor: r.text,
          text: f.text
        };
        break;
      }
      case "UFID": {
        const s = l.readIdentifierAndData(e, u);
        c = { owner_identifier: s.id, identifier: s.data };
        break;
      }
      case "PRIV": {
        const s = l.readIdentifierAndData(e, u);
        c = { owner_identifier: s.id, data: s.data };
        break;
      }
      case "POPM": {
        e = e.subarray(d);
        const s = l.readNullTerminatedString(e, M), r = s.text;
        if (e = e.subarray(s.len), e.length === 0) {
          this.warningCollector.addWarning(`id3v2.${this.major} type=${t} POPM frame missing rating byte`), c = { email: r, rating: 0, counter: void 0 };
          break;
        }
        const f = U.get(e, 0), p = e.subarray(U.len);
        c = {
          email: r,
          rating: f,
          counter: p.length > 0 ? j(p) : void 0
        };
        break;
      }
      case "GEOB": {
        const s = N.get(e, 0);
        e = e.subarray(1);
        const r = l.readNullTerminatedString(e, M), f = r.text;
        e = e.subarray(r.len);
        const p = l.readNullTerminatedString(e, s), k = p.text;
        e = e.subarray(p.len);
        const S = l.readNullTerminatedString(e, s), D = S.text;
        e = e.subarray(S.len), c = {
          type: f,
          filename: k,
          description: D,
          data: e
        };
        break;
      }
      case "WCOM":
      case "WCOP":
      case "WOAF":
      case "WOAR":
      case "WOAS":
      case "WORS":
      case "WPAY":
      case "WPUB":
        c = l.readNullTerminatedString(e, M).text;
        break;
      case "WXXX": {
        const s = N.get(e, 0);
        e = e.subarray(1);
        const r = l.readNullTerminatedString(e, s), f = r.text;
        e = e.subarray(r.len), c = { description: f, url: l.trimNullPadding(T(e, u)) };
        break;
      }
      case "WFD":
      case "WFED": {
        const s = N.get(e, 0);
        e = e.subarray(1), c = l.readNullTerminatedString(e, s).text;
        break;
      }
      case "MCDI": {
        c = e.subarray(0, g);
        break;
      }
      case "CHAP": {
        $("Reading CHAP"), h = I(e, u);
        const s = {
          label: T(e.subarray(0, h), u),
          info: F.get(e, h + 1),
          frames: /* @__PURE__ */ new Map()
        };
        for (d += h + 1 + F.len; d < g; ) {
          const r = L(e.subarray(d), this.major, this.warningCollector), f = W(this.major);
          d += f;
          const p = this.readData(e.subarray(d, d + r.length), r.id, a);
          d += r.length, s.frames.set(r.id, p);
        }
        c = s;
        break;
      }
      case "CTOC": {
        $("Reading CTOC");
        const s = I(e, u), r = T(e.subarray(0, s), u);
        d = s + 1;
        const f = e[d++], p = (f & 2) !== 0, k = (f & 1) !== 0, S = e[d++], D = [];
        for (let x = 0; x < S && d < g; x++) {
          const v = I(e.subarray(d), u), O = T(e.subarray(d, d + v), u);
          D.push(O), d += v + 1;
        }
        const H = {
          label: r,
          flags: { topLevel: p, ordered: k },
          childElementIds: D,
          frames: /* @__PURE__ */ new Map()
        };
        for (; d < g; ) {
          const x = L(e.subarray(d), this.major, this.warningCollector), v = W(this.major);
          d += v;
          const O = this.readData(e.subarray(d, d + x.length), x.id, a);
          d += x.length, H.frames.set(x.id, O);
        }
        c = H;
        break;
      }
      default:
        $(`Warning: unsupported id3v2-tag-type: ${t}`);
        break;
    }
    return c;
  }
  static readNullTerminatedString(e, t) {
    const a = t.bom ? 2 : 0, i = e.length, o = e.subarray(a), g = I(o, t.encoding);
    if (g >= o.length)
      return {
        text: T(o, t.encoding),
        len: i
      };
    const d = o.subarray(0, g);
    return {
      text: T(d, t.encoding),
      len: a + g + l.getNullTerminatorLength(t.encoding)
    };
  }
  static fixPictureMimeType(e) {
    switch (e = e.toLocaleLowerCase(), e) {
      case "jpg":
        return "image/jpeg";
      case "png":
        return "image/png";
    }
    return e;
  }
  /**
   * Converts TMCL (Musician credits list) or TIPL (Involved people list)
   * @param entries
   */
  static functionList(e) {
    const t = {};
    for (let a = 0; a + 1 < e.length; a += 2) {
      const i = e[a + 1].split(",");
      t[e[a]] = t[e[a]] ? t[e[a]].concat(i) : i;
    }
    return t;
  }
  /**
   * id3v2.4 defines that multiple T* values are separated by 0x00
   * id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /
   * @param tag - Tag name
   * @param text - Concatenated tag value
   * @returns Split tag value
   */
  splitValue(e, t) {
    let a;
    return this.major < 4 ? (a = t.split(/\x00/g), a.length > 1 ? this.warningCollector.addWarning(`ID3v2.${this.major} ${e} uses non standard null-separator.`) : a = t.split(/\//g)) : a = t.split(/\x00/g), l.trimArray(a);
  }
  static trimArray(e) {
    return e.map((t) => l.trimNullPadding(t).trim());
  }
  static trimNullPadding(e) {
    let t = e.length;
    for (; t > 0 && e.charCodeAt(t - 1) === 0; )
      t--;
    return t === e.length ? e : e.slice(0, t);
  }
  static readIdentifierAndData(e, t) {
    const a = l.readNullTerminatedString(e, { encoding: t, bom: !1 });
    return { id: a.text, data: e.subarray(a.len) };
  }
  static getNullTerminatorLength(e) {
    return e.startsWith("utf-16") ? 2 : 1;
  }
}
class E extends Q("id3v2") {
}
function ae(n) {
  throw new E(`Unexpected majorVer: ${n}`);
}
class C {
  constructor() {
    this.tokenizer = void 0, this.id3Header = void 0, this.metadata = void 0, this.headerType = void 0, this.options = void 0;
  }
  static removeUnsyncBytes(e) {
    let t = 0, a = 0;
    for (; t < e.length - 1; )
      t !== a && (e[a] = e[t]), t += e[t] === 255 && e[t + 1] === 0 ? 2 : 1, a++;
    return t < e.length && (e[a++] = e[t]), e.subarray(0, a);
  }
  static readFrameData(e, t, a, i, o) {
    var d, c;
    const g = new l(a, o);
    switch (a) {
      case 2:
        return g.readData(e, t.id, i);
      case 3:
      case 4:
        return (d = t.flags) != null && d.format.unsynchronisation && (e = C.removeUnsyncBytes(e)), (c = t.flags) != null && c.format.data_length_indicator && (e = e.subarray(4, e.length)), g.readData(e, t.id, i);
      default:
        throw se(a);
    }
  }
  /**
   * Create a combined tag key, of tag & description
   * @param tag e.g.: COM
   * @param description e.g. iTunPGAP
   * @returns string e.g. COM:iTunPGAP
   */
  static makeDescriptionTagName(e, t) {
    return e + (t ? `:${t}` : "");
  }
  async parse(e, t, a) {
    this.tokenizer = t, this.metadata = e, this.options = a;
    const i = await this.tokenizer.readToken(J);
    if (i.fileIdentifier !== "ID3")
      throw new E("expected ID3-header file-identifier 'ID3' was not found");
    this.id3Header = i, this.headerType = `ID3v2.${i.version.major}`, await (i.flags.isExtendedHeader ? this.parseExtendedHeader() : this.parseId3Data(i.size));
    const o = C.mapId3v2Chapters(this.metadata.native[this.headerType]);
    this.metadata.setFormat("chapters", o);
  }
  async parseExtendedHeader() {
    const e = await this.tokenizer.readToken(P), t = e.size - P.len;
    return t > 0 ? this.parseExtendedHeaderData(t, e.size) : this.parseId3Data(this.id3Header.size - e.size);
  }
  async parseExtendedHeaderData(e, t) {
    return await this.tokenizer.ignore(e), this.parseId3Data(this.id3Header.size - t);
  }
  async parseId3Data(e) {
    const t = await this.tokenizer.readToken(new y(e));
    for (const a of this.parseMetadata(t))
      switch (a.id) {
        case "TXXX":
          a.value && await this.handleTag(a, a.value.text, () => a.value.description);
          break;
        default:
          await (Array.isArray(a.value) ? Promise.all(a.value.map((i) => this.addTag(a.id, i))) : this.addTag(a.id, a.value));
      }
  }
  async handleTag(e, t, a, i = (o) => o) {
    await Promise.all(t.map((o) => this.addTag(C.makeDescriptionTagName(e.id, a(o)), i(o))));
  }
  async addTag(e, t) {
    await this.metadata.addTag(this.headerType, e, t);
  }
  parseMetadata(e) {
    let t = 0;
    const a = [];
    for (; t !== e.length; ) {
      const i = W(this.id3Header.version.major);
      if (t + i > e.length) {
        this.metadata.addWarning("Illegal ID3v2 tag length");
        break;
      }
      const o = e.subarray(t, t + i);
      t += i;
      const g = L(o, this.id3Header.version.major, this.metadata), d = e.subarray(t, t + g.length);
      t += g.length;
      const c = C.readFrameData(d, g, this.id3Header.version.major, !this.options.skipCovers, this.metadata);
      c && a.push({ id: g.id, value: c });
    }
    return a;
  }
  /**
   * Convert parsed ID3v2 chapter frames (CHAP / CTOC) to generic `format.chapters`.
   *
   * This function expects the `native` tags already to contain parsed `CHAP` and `CTOC` frame values,
   * as produced by `FrameParser.readData`.
   */
  static mapId3v2Chapters(e) {
    if (!e)
      return;
    const t = e.filter((m) => m.id === "CHAP");
    if (!(t != null && t.length))
      return;
    const a = e.filter((m) => m.id === "CTOC"), i = a == null ? void 0 : a.find((m) => {
      var h;
      return (h = m.value.flags) == null ? void 0 : h.topLevel;
    }), o = /* @__PURE__ */ new Map();
    for (const m of t)
      o.set(m.value.label, m.value);
    const g = i == null ? void 0 : i.value.childElementIds, d = [], c = g ?? [...o.keys()];
    for (const m of c) {
      const h = o.get(m);
      if (!h)
        continue;
      const s = h.frames, r = s.get("TIT2");
      r && d.push({
        id: m,
        title: r,
        url: s.get("WXXX"),
        start: h.info.startTime / 1e3,
        end: h.info.endTime / 1e3,
        image: s.get("APIC")
      });
    }
    return g || d.sort((m, h) => m.start - h.start), d.length ? d : void 0;
  }
}
function se(n) {
  throw new E(`Unexpected majorVer: ${n}`);
}
export {
  C as I
};
